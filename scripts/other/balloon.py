import pygame
import random
import math
import numpy as np
import itertools

# --- Constants ---

# Screen/Scaling Settings
PIXEL_SCALE = 2  # Factor by which the low-resolution surface is scaled up for display
LOW_RES_WIDTH, LOW_RES_HEIGHT = 400, 350 # Dimensions of the internal rendering surface
WIDTH, HEIGHT = LOW_RES_WIDTH * PIXEL_SCALE, LOW_RES_HEIGHT * PIXEL_SCALE # Final window dimensions
CENTER_X, CENTER_Y = LOW_RES_WIDTH // 2, LOW_RES_HEIGHT // 2 # Center coordinates of the low-res surface

# Simulation Physics Parameters
FPS = 60             # Target frames per second for the simulation
DAMPING = 0.99999    # Velocity damping factor applied each frame to simulate air resistance/energy loss
EPSILON = 1e-9       # A small number to prevent division by zero in calculations

# Colors (Standard RGB tuples)
WHITE = (255, 255, 255)
RED = (220, 50, 50)
DARK_RED = (150, 30, 30) # Used for balloon outline
YELLOW = (255, 255, 0)
ORANGE = (255, 165, 0)
GRAY = (150, 150, 150)
DARK_GRAY = (80, 80, 80) # Used for slider background
BLACK = (0, 0, 0)
SKY_BLUE = (135, 206, 235) # Background color
LIGHT_GRAY = (200, 200, 200) # Used for cloud shadows
BROWN = (139, 69, 19) # Used for the balloon string

# Particle Simulation Settings
NUM_PARTICLES = 50        # Number of particles inside the balloon
PARTICLE_RADIUS_MIN = 1   # Minimum radius of a particle (in pixels on low-res surface)
PARTICLE_RADIUS_MAX = 2   # Maximum radius of a particle (in pixels on low-res surface)
PARTICLE_BASE_SPEED = 0.25 # Base speed multiplier for particles
TRAIL_LENGTH = 10         # Number of previous positions stored for drawing trails

# Balloon Settings
BALLOON_BASE_RADIUS = 35      # Initial radius of the balloon (in pixels on low-res surface)
BALLOON_COLOR = RED           # Fill color of the balloon
BALLOON_CENTER = np.array([CENTER_X, CENTER_Y], dtype=np.float32) # Center position of the balloon
SECRET_EXPLOSION_RADIUS = 65  # Balloon radius threshold that triggers the explosion
STRING_COLOR = BROWN          # Color of the balloon's string
STRING_LENGTH = 40            # Length of the balloon's string (in pixels on low-res surface)

# Temperature Slider Settings (Coordinates on low-res surface)
SLIDER_X = 10                 # X position of the slider
SLIDER_Y = LOW_RES_HEIGHT - 15 # Y position of the slider
SLIDER_WIDTH = 60             # Width of the slider bar
SLIDER_HEIGHT = 5             # Height of the slider bar
SLIDER_HANDLE_WIDTH = 3       # Width of the slider handle
SLIDER_HANDLE_HEIGHT = 7      # Height of the slider handle
SLIDER_MIN_TEMP = 0.2         # Minimum temperature multiplier
SLIDER_MAX_TEMP = 3.0         # Maximum temperature multiplier

# Explosion Effect Settings (Dimensions on low-res surface)
EXPLOSION_PARTICLES = 30     # Number of particles generated by the explosion effect
EXPLOSION_DURATION = 100     # Duration of the explosion effect in frames
EXPLOSION_MAX_RADIUS = 40    # Maximum radius reached by the explosion shockwave
EXPLOSION_COLORS = [RED, ORANGE, YELLOW, WHITE] # Colors used for explosion particles

# Spatial Grid Settings for Collision Optimization
# Cell size should be large enough to contain the largest particles comfortably
GRID_CELL_SIZE = PARTICLE_RADIUS_MAX * 4

# Cloud Settings
NUM_CLOUDS = 5              # Number of clouds in the sky
CLOUD_MIN_SPEED = 0.1       # Minimum horizontal speed of clouds (pixels/frame on low-res)
CLOUD_MAX_SPEED = 0.4       # Maximum horizontal speed of clouds (pixels/frame on low-res)
CLOUD_COLOR = WHITE         # Main color of the clouds
CLOUD_SHADOW_COLOR = LIGHT_GRAY # Color for the simple cloud shadow effect

# --- Utility Functions ---

def get_cell_coords(pos_array):
    """Calculates the grid cell coordinates for an array of particle positions.

    Args:
        pos_array (np.ndarray): A NumPy array of shape (N, 2) containing particle positions.

    Returns:
        np.ndarray: A NumPy array of shape (N, 2) containing integer grid coordinates.
    """
    return (pos_array // GRID_CELL_SIZE).astype(int)

# --- NumPy-based Particle Update Functions ---
# These functions perform physics calculations efficiently using NumPy arrays.
# They operate on coordinates within the LOW_RES_WIDTH/HEIGHT bounds.

def set_temperature_np(velocities, current_temp_factors, target_temp_factor):
    """Adjusts particle velocities to match a target temperature factor using NumPy.

    Temperature is modeled as the average kinetic energy (proportional to speed squared).
    This function scales velocities to approach the target temperature. It also gives
    a minimum speed boost to stationary particles.

    Args:
        velocities (np.ndarray): Array of particle velocities (N, 2). Modified in-place.
        current_temp_factors (np.ndarray): Array storing the last applied temp factor (N,). Modified in-place.
        target_temp_factor (float): The desired temperature factor to scale speeds towards.
    """
    speeds_sq = np.sum(velocities**2, axis=1)
    speeds = np.sqrt(speeds_sq + EPSILON) # Add EPSILON for numerical stability

    # Calculate the ratio needed to scale current speed to target speed
    # Use maximum to avoid issues with zero temperature factors
    safe_current_temp = np.maximum(current_temp_factors, EPSILON)
    speed_ratio = np.sqrt(target_temp_factor / safe_current_temp)

    # Calculate new speeds based on the ratio
    new_speeds = speeds * speed_ratio

    # Ensure particles have a minimum kinetic energy, especially when temp increases
    min_boost = PARTICLE_BASE_SPEED * math.sqrt(target_temp_factor) * 0.2
    final_speeds = np.maximum(new_speeds, min_boost)

    # Calculate scaling factors for velocity vectors
    scale_factors = final_speeds / (speeds + EPSILON)

    # Identify particles nearly at rest
    at_rest_indices = np.where(speeds < EPSILON)[0]

    # Scale existing velocities
    velocities *= scale_factors[:, np.newaxis] # Use broadcasting

    # Give resting particles a random initial velocity based on target temp
    if len(at_rest_indices) > 0:
        num_at_rest = len(at_rest_indices)
        angles = np.random.uniform(0, 2 * math.pi, num_at_rest)
        vel_components = np.column_stack((np.cos(angles), np.sin(angles)))
        velocities[at_rest_indices] = vel_components * (PARTICLE_BASE_SPEED * math.sqrt(target_temp_factor))

    # Update the stored temperature factors
    current_temp_factors[:] = target_temp_factor


def move_particles_np(positions, velocities, trail_history):
    """Updates particle positions based on velocities and records history for trails.

    Args:
        positions (np.ndarray): Particle positions (N, 2). Modified in-place.
        velocities (np.ndarray): Particle velocities (N, 2).
        trail_history (np.ndarray): History of particle positions (N, TRAIL_LENGTH, 2). Modified in-place.
    """
    # Shift trail history back, making space for the current position at the front
    trail_history[:] = np.roll(trail_history, shift=1, axis=1)
    trail_history[:, 0, :] = positions # Store current position

    # Update positions based on velocity
    positions += velocities


def collide_balloon_np(positions, velocities, radii, center, radius):
    """Handles collisions between particles and the circular balloon boundary using NumPy.

    Particles hitting the boundary have their position corrected (pushed back inside)
    and their velocity reflected.

    Args:
        positions (np.ndarray): Particle positions (N, 2). Modified in-place.
        velocities (np.ndarray): Particle velocities (N, 2). Modified in-place.
        radii (np.ndarray): Particle radii (N,).
        center (np.ndarray): Balloon center coordinates (2,).
        radius (float): Current radius of the balloon.
    """
    dist_vecs = positions - center # Vectors from balloon center to particles
    distances_sq = np.sum(dist_vecs**2, axis=1) # Squared distances

    # Maximum allowed distance from center for each particle (balloon radius - particle radius)
    max_dist_allowed = radius - radii
    # Prevent negative allowed distance if balloon shrinks smaller than largest particle
    max_dist_allowed = np.maximum(max_dist_allowed, 0)
    max_dist_sq_allowed = max_dist_allowed**2

    # Find indices of particles that are outside their allowed distance
    collision_indices = np.where(distances_sq > max_dist_sq_allowed)[0]

    if len(collision_indices) > 0:
        colliding_vecs = dist_vecs[collision_indices]
        colliding_dist_sq = distances_sq[collision_indices]
        colliding_dist = np.sqrt(colliding_dist_sq + EPSILON)
        colliding_radii = radii[collision_indices]

        # --- 1. Resolve Overlap (Position Correction) ---
        # Calculate how much the particle is outside its allowed boundary
        overlap = colliding_dist - (radius - colliding_radii)
        # Only apply correction if overlap is positive (i.e., actually overlapping)
        overlap = np.maximum(overlap, 0)

        # Calculate normal vectors (pointing from center to particle)
        normal_vecs = colliding_vecs / (colliding_dist[:, np.newaxis] + EPSILON)

        # Push particles back along the normal vector by the overlap amount
        positions[collision_indices] -= normal_vecs * overlap[:, np.newaxis]

        # --- 2. Reflect Velocity ---
        colliding_vels = velocities[collision_indices]
        # Dot product of velocity and normal indicates movement towards/away from boundary
        dot_products = np.sum(colliding_vels * normal_vecs, axis=1)

        # We only reflect velocity if the particle is moving outwards (positive dot product)
        needs_reflection = dot_products > 0
        indices_to_reflect = collision_indices[needs_reflection]

        if len(indices_to_reflect) > 0:
            vels_to_reflect = velocities[indices_to_reflect]
            normals_to_reflect = normal_vecs[needs_reflection]
            dots_to_reflect = dot_products[needs_reflection]

            # Standard reflection formula: v_new = v_old - 2 * dot(v_old, normal) * normal
            velocities[indices_to_reflect] = vels_to_reflect - 2 * dots_to_reflect[:, np.newaxis] * normals_to_reflect


def collide_particles_np_grid(positions, velocities, radii, masses, grid, processed_pairs):
    """Handles particle-particle collisions using a spatial grid for optimization.

    Detects collisions between pairs of particles, resolves overlap by pushing
    them apart, and calculates new velocities based on elastic collision physics.

    Args:
        positions (np.ndarray): Particle positions (N, 2). Modified in-place.
        velocities (np.ndarray): Particle velocities (N, 2). Modified in-place.
        radii (np.ndarray): Particle radii (N,).
        masses (np.ndarray): Particle masses (N,).
        grid (dict): Spatial grid mapping cell coordinates (tuple) to lists of particle indices.
        processed_pairs (set): A set to keep track of particle pairs already processed in this frame
                               to avoid redundant calculations. Modified in-place.
    """
    processed_pairs.clear() # Clear pairs from the previous frame

    # Iterate through each cell in the grid containing particles
    for cell_coords, particle_indices_in_cell in grid.items():
        cx, cy = cell_coords
        indices_to_check = list(particle_indices_in_cell) # Start with particles in this cell

        # Add particles from neighboring cells (including diagonals)
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0: continue # Skip the cell itself (already included)
                neighbor_coords = (cx + dx, cy + dy)
                if neighbor_coords in grid:
                    indices_to_check.extend(grid[neighbor_coords])

        # Need at least two unique particles to check for collisions
        if len(indices_to_check) >= 2:
            # Ensure unique indices before generating combinations
            unique_indices = list(set(indices_to_check))
            if len(unique_indices) < 2: continue

            # Check all unique pairs within the current cell and its neighbors
            for i, j in itertools.combinations(unique_indices, 2):
                # Sort indices to ensure pair (i, j) is treated the same as (j, i)
                pair = tuple(sorted((i, j)))
                if pair in processed_pairs:
                    continue # Skip if this pair has already been processed this frame
                processed_pairs.add(pair)

                # Get data for the pair of particles
                pos_i, pos_j = positions[i], positions[j]
                vel_i, vel_j = velocities[i], velocities[j]
                rad_i, rad_j = radii[i], radii[j]
                m_i, m_j = masses[i], masses[j]

                # Collision Detection
                dist_vec = pos_i - pos_j
                dist_sq = np.sum(dist_vec**2)
                min_dist = rad_i + rad_j # Minimum distance for collision (sum of radii)
                min_dist_sq = min_dist**2

                # Check for overlap (distance squared < minimum distance squared)
                # Also ensure distance is not effectively zero to avoid division issues
                if dist_sq < min_dist_sq and dist_sq > EPSILON:
                    # --- 1. Resolve Overlap ---
                    dist = math.sqrt(dist_sq)
                    overlap = min_dist - dist
                    normal = dist_vec / dist # Normalized vector pointing from j to i

                    # Push particles apart along the normal vector
                    # Each particle moves half the overlap distance
                    # Use masses for weighted correction (optional, simpler correction used here)
                    correction = normal * (overlap / 2.0)
                    positions[i] += correction
                    positions[j] -= correction

                    # --- 2. Calculate Collision Response (Elastic Collision) ---
                    # Recalculate normal vector after position correction for accuracy
                    dist_vec = positions[i] - positions[j]
                    dist_sq = np.sum(dist_vec**2)
                    if dist_sq > EPSILON:
                         normal = dist_vec / math.sqrt(dist_sq)
                    else:
                         # If perfectly overlapped after correction, choose a random normal
                         angle = random.uniform(0, 2 * math.pi)
                         normal = np.array([math.cos(angle), math.sin(angle)])

                    # Calculate tangent vector (perpendicular to normal)
                    tangent = np.array([-normal[1], normal[0]])

                    # Project velocities onto normal and tangent vectors
                    dp_normal_i = np.dot(vel_i, normal)
                    dp_tangent_i = np.dot(vel_i, tangent)
                    dp_normal_j = np.dot(vel_j, normal)
                    dp_tangent_j = np.dot(vel_j, tangent)

                    # Calculate new normal velocities using 1D elastic collision formula
                    total_mass = m_i + m_j
                    # Avoid division by zero if total mass is negligible
                    if total_mass < EPSILON: total_mass = 1.0

                    # Formula derived from conservation of momentum and kinetic energy
                    new_dp_normal_i = (dp_normal_i * (m_i - m_j) + 2 * m_j * dp_normal_j) / total_mass
                    new_dp_normal_j = (dp_normal_j * (m_j - m_i) + 2 * m_i * dp_normal_i) / total_mass

                    # Tangential velocities remain unchanged in frictionless collisions
                    # Combine new normal and original tangent velocities to get final velocity vectors
                    velocities[i] = normal * new_dp_normal_i + tangent * dp_tangent_i
                    velocities[j] = normal * new_dp_normal_j + tangent * dp_tangent_j


# --- Slider Class ---
class Slider:
    """A simple draggable slider UI element for adjusting temperature."""
    def __init__(self, x, y, w, h, min_val, max_val, initial_val):
        """Initializes the slider.

        Args:
            x, y (int): Top-left coordinates on the low-res surface.
            w, h (int): Width and height of the slider bar on the low-res surface.
            min_val (float): Minimum value the slider can represent.
            max_val (float): Maximum value the slider can represent.
            initial_val (float): Starting value of the slider.
        """
        self.rect = pygame.Rect(x, y, w, h) # The background bar
        self.min_val = min_val
        self.max_val = max_val
        self.val = initial_val
        # The draggable handle
        self.handle_rect = pygame.Rect(0, 0, SLIDER_HANDLE_WIDTH, SLIDER_HANDLE_HEIGHT)
        self.update_handle_pos() # Position handle based on initial value
        self.dragging = False # True if the user is currently dragging the handle

    def update_handle_pos(self):
        """Calculates and updates the handle's position based on the current value."""
        # Determine the position ratio (0.0 to 1.0) based on the value
        value_range = self.max_val - self.min_val
        ratio = (self.val - self.min_val) / value_range if value_range != 0 else 0
        # Calculate the handle's center x-coordinate
        handle_x = self.rect.x + ratio * self.rect.width
        # Set the handle's center position
        self.handle_rect.center = (handle_x, self.rect.centery)

    def draw(self, surface, font):
        """Draws the slider onto the provided low-resolution surface.

        Args:
            surface (pygame.Surface): The low-res surface to draw on.
            font (pygame.font.Font): The font used for rendering the value text.
        """
        # Draw the slider bar (background)
        pygame.draw.rect(surface, DARK_GRAY, self.rect)
        # Draw the handle
        pygame.draw.rect(surface, GRAY, self.handle_rect)
        # Render and draw the current value text next to the slider
        text = font.render(f"Temp: {self.val:.1f}x", True, BLACK)
        surface.blit(text, (self.rect.right + 3, self.rect.centery - text.get_height() // 2))

    def handle_event(self, event, scale_factor):
        """Processes Pygame events to handle mouse interaction with the slider.

        Args:
            event (pygame.event.Event): The Pygame event to process.
            scale_factor (int): The factor used to scale display coordinates down to
                                low-res surface coordinates.
        """
        if event.type == pygame.MOUSEBUTTONDOWN:
            # Convert mouse position from screen coordinates to low-res surface coordinates
            mouse_pos_scaled = (event.pos[0] // scale_factor, event.pos[1] // scale_factor)
            # Check if the click is on the handle or the slider bar
            if self.handle_rect.collidepoint(mouse_pos_scaled):
                self.dragging = True
            elif self.rect.collidepoint(mouse_pos_scaled):
                 self.dragging = True
                 # If clicking directly on the bar, jump the handle to that position
                 self.update_value_from_pos(mouse_pos_scaled[0])

        elif event.type == pygame.MOUSEBUTTONUP:
            # Stop dragging when the mouse button is released
            self.dragging = False
        elif event.type == pygame.MOUSEMOTION:
            # If dragging, update the slider value based on the mouse position
            if self.dragging:
                 mouse_pos_scaled = (event.pos[0] // scale_factor, event.pos[1] // scale_factor)
                 self.update_value_from_pos(mouse_pos_scaled[0])

    def update_value_from_pos(self, mouse_x_scaled):
        """Updates the slider's value based on the scaled mouse x-coordinate.

        Args:
            mouse_x_scaled (int): The mouse's x-coordinate relative to the low-res surface.
        """
        # Calculate the horizontal position relative to the start of the slider bar
        relative_x = mouse_x_scaled - self.rect.x
        # Calculate the ratio (0.0 to 1.0) along the slider's width
        ratio = max(0, min(1, relative_x / self.rect.width)) # Clamp between 0 and 1
        # Calculate the corresponding value within the min/max range
        self.val = self.min_val + ratio * (self.max_val - self.min_val)
        # Update the handle's visual position
        self.update_handle_pos()

    def get_value(self):
        """Returns the current value of the slider."""
        return self.val

# --- ExplosionEffect Class ---
class ExplosionEffect:
    """Manages the visual effect of the balloon exploding."""
    def __init__(self, center, num_particles, duration, max_radius, colors):
        """Initializes the explosion effect.

        Args:
            center (tuple): The center coordinates (x, y) of the explosion on the low-res surface.
            num_particles (int): How many particles the effect should generate.
            duration (int): How many frames the effect should last.
            max_radius (int): The maximum radius the shockwave should reach on the low-res surface.
            colors (list): A list of colors to use for the explosion particles.
        """
        self.center = pygame.Vector2(center) # Use Vector2 for easier math
        self.duration = duration
        self.max_radius = max_radius # Max radius on low-res surface
        self.colors = colors
        self.particles = []          # List to store particle dictionaries
        self.timer = 0               # Frames elapsed since the start of the explosion
        self.shockwave_radius = 0    # Current radius of the visual shockwave effect
        self.shockwave_alpha = 255   # Current transparency of the shockwave

        # Create the individual explosion particles
        for _ in range(num_particles):
            angle = random.uniform(0, 2 * math.pi)
            # Particles shoot outwards with random speed
            speed = random.uniform(1, 4) # Speed suitable for low-res surface
            vel = pygame.Vector2(math.cos(angle), math.sin(angle)) * speed
            radius = random.uniform(1, 2) # Pixel-sized particles (1 or 2 pixels radius)
            color = random.choice(colors)
            # Store particle data in a dictionary
            self.particles.append({
                'pos': pygame.Vector2(center), # Start at the center
                'vel': vel,
                'radius': radius, # Use float for smooth shrinking
                'color': color,
                'life': random.uniform(0.5, 1.0), # Fraction of duration particle lives
                'active': True # Whether the particle is currently visible/updated
            })

    def update(self):
        """Updates the state of the explosion effect (particles and shockwave).

        Returns:
            bool: True if the effect is still active, False if it has finished.
        """
        # Stop updating if the duration is reached
        if self.timer >= self.duration:
            return False

        self.timer += 1
        # Calculate progress ratio (0.0 to 1.0)
        time_ratio = self.timer / self.duration

        # Update shockwave radius and alpha based on time
        self.shockwave_radius = time_ratio * self.max_radius
        # Fade out the shockwave (fades faster than it expands)
        self.shockwave_alpha = max(0, 255 * (1 - time_ratio * 1.5))

        # Update each active particle
        for p in self.particles:
            if p['active']:
                p['pos'] += p['vel']
                p['vel'] *= 0.97 # Apply damping to slow particles down

                # Start shrinking the particle after its designated lifespan fraction
                if time_ratio > p['life']:
                    p['radius'] *= 0.92 # Shrink rate
                    # Deactivate particle when it becomes too small (less than half a pixel)
                    if p['radius'] < 0.5:
                        p['active'] = False
        return True # Effect is still ongoing

    def draw(self, surface):
        """Draws the explosion effect onto the low-resolution surface.

        Args:
            surface (pygame.Surface): The low-res surface to draw on.
        """
        # --- Draw Shockwave ---
        shock_radius_int = int(self.shockwave_radius)
        # Only draw if shockwave is large enough and not fully transparent
        if self.shockwave_alpha > 10 and shock_radius_int > 0:
             alpha = int(self.shockwave_alpha)
             # Create a temporary surface for drawing the circle with alpha
             # Add padding to avoid clipping the outline
             temp_surf_size = shock_radius_int * 2 + 2
             try:
                temp_surf = pygame.Surface((temp_surf_size, temp_surf_size), pygame.SRCALPHA)
                # Draw a 1-pixel wide circle outline with the calculated alpha
                pygame.draw.circle(
                    temp_surf,
                    (*WHITE[:3], alpha), # Use white color with alpha
                    (shock_radius_int + 1, shock_radius_int + 1), # Center on temp surface
                    shock_radius_int,
                    width=1 # Outline only
                )
                # Blit the temporary surface onto the main low-res surface
                surface.blit(temp_surf, (int(self.center.x - shock_radius_int - 1),
                                         int(self.center.y - shock_radius_int - 1)))
             except (ValueError, OverflowError): # Catch errors if radius becomes invalid
                pass # Skip drawing if parameters are bad

        # --- Draw Particles ---
        for p in self.particles:
             if p['active']:
                 radius_int = int(p['radius'])
                 # Only draw if particle is at least 1 pixel in radius
                 if radius_int > 0:
                     # Calculate alpha based on fade-out phase
                     alpha = 255
                     if self.timer / self.duration > p['life']:
                         # Calculate remaining life fraction after fade starts
                         life_left_ratio = max(0, (self.timer / self.duration - p['life']) / (1.0 - p['life']))
                         alpha = int(255 * (1.0 - life_left_ratio))
                         alpha = max(0, min(255, alpha)) # Clamp alpha between 0 and 255

                     # Only draw if sufficiently visible
                     if alpha > 10:
                         color_tuple = (*p['color'][:3], alpha) # Combine base color with alpha
                         # Calculate top-left corner for drawing
                         pos_int = (int(p['pos'].x - radius_int), int(p['pos'].y - radius_int))
                         dim = radius_int * 2 # Diameter for drawing rectangle/surface
                         try:
                            # Use a small temporary surface for each particle to handle alpha correctly
                            part_surf = pygame.Surface((dim, dim), pygame.SRCALPHA)
                            # Draw a rectangle for a blocky pixel look
                            pygame.draw.rect(part_surf, color_tuple, (0, 0, dim, dim))
                            # Alternative: draw a circle
                            # pygame.draw.circle(part_surf, color_tuple, (radius_int, radius_int), radius_int)
                            surface.blit(part_surf, pos_int)
                         except (ValueError, OverflowError): # Catch errors with extreme coordinates/sizes
                             pass # Skip drawing this particle if parameters are bad


# --- Cloud Class ---
class Cloud:
    """Represents a simple, moving cloud for background decoration."""
    def __init__(self):
        """Initializes a cloud with random properties and positions it off-screen."""
        self.reset()
        # Allow some clouds to start partially or fully on screen initially
        self.x = random.uniform(-LOW_RES_WIDTH * 0.2, LOW_RES_WIDTH * 1.2)

    def reset(self, going_right=None):
        """Resets cloud properties (size, speed, position) and places it off-screen."""
        # Randomize dimensions
        self.width = random.randint(15, 40) # Width in pixels on low-res surface
        self.height = random.randint(5, 15) # Height in pixels on low-res surface
        # Ensure clouds stay within the upper half of the screen vertically
        self.y = random.randint(5, LOW_RES_HEIGHT // 2 - self.height)
        # Randomize speed
        self.speed = random.uniform(CLOUD_MIN_SPEED, CLOUD_MAX_SPEED)

        # Determine direction and starting position (off-screen)
        if going_right is None:
            going_right = random.choice([True, False]) # Choose initial direction randomly

        if going_right:
            self.speed = abs(self.speed) # Ensure positive speed for rightward movement
            # Start off the left edge
            self.x = -self.width - random.randint(10, 50)
        else:
            self.speed = -abs(self.speed) # Ensure negative speed for leftward movement
            # Start off the right edge
            self.x = LOW_RES_WIDTH + random.randint(10, 50)

    def update(self):
        """Moves the cloud horizontally and wraps it around the screen edges."""
        self.x += self.speed
        # Check if cloud has moved completely off-screen
        if self.speed > 0 and self.x > LOW_RES_WIDTH + 10: # Moved off right edge
             self.reset(going_right=False) # Reset to appear from the right next time
        elif self.speed < 0 and self.x < -self.width - 10: # Moved off left edge
              self.reset(going_right=True) # Reset to appear from the left next time

    def draw(self, surface):
        """Draws the cloud as simple rectangles onto the low-res surface."""
        shadow_offset = 1 # Simple 1-pixel shadow offset

        # Draw the shadow part slightly offset
        pygame.draw.rect(surface, CLOUD_SHADOW_COLOR,
                         (int(self.x + shadow_offset), int(self.y + shadow_offset),
                          self.width, self.height))
        # Draw the main cloud body
        pygame.draw.rect(surface, CLOUD_COLOR,
                         (int(self.x), int(self.y), self.width, self.height))
        # Optional: Draw smaller overlapping rects for a fluffier look
        # sub_w = self.width * 0.6
        # sub_h = self.height * 0.8
        # pygame.draw.rect(surface, CLOUD_COLOR, (int(self.x + self.width*0.2), int(self.y - sub_h*0.3), int(sub_w), int(sub_h)))


# --- Game Setup ---
pygame.init()

# Create the main display window (high-resolution)
screen = pygame.display.set_mode((WIDTH, HEIGHT))
# Create the internal surface for low-resolution rendering
pixel_surface = pygame.Surface((LOW_RES_WIDTH, LOW_RES_HEIGHT))

pygame.display.set_caption("Pixel Hot Air Balloon Simulation (NumPy)")
clock = pygame.time.Clock() # For controlling frame rate

# Setup font for UI text (use smaller size for low-res surface)
font_size = 10 if PIXEL_SCALE >= 4 else 14 # Adjust font size based on scaling
try:
    # Attempt to load a pixel-style font (replace with your font file if available)
    # e.g., font = pygame.font.Font("PressStart2P-Regular.ttf", font_size)
    font = pygame.font.SysFont("monospace", font_size, bold=True) # Fallback to monospace
except Exception: # Catch potential font loading errors
    print("Font loading failed, using default monospace font.")
    font = pygame.font.SysFont("monospace", font_size, bold=True)

# --- Game Variables ---

# Balloon State
current_balloon_radius = float(BALLOON_BASE_RADIUS) # Start with the base radius

# Particle Data (NumPy Arrays for efficiency)
positions = np.zeros((NUM_PARTICLES, 2), dtype=np.float32) # (x, y) coordinates
velocities = np.zeros((NUM_PARTICLES, 2), dtype=np.float32) # (vx, vy) velocities
# Assign random radii within the defined range
radii = np.random.randint(PARTICLE_RADIUS_MIN, PARTICLE_RADIUS_MAX + 1, NUM_PARTICLES).astype(np.float32)
# Calculate mass based on area (pi * r^2, but pi is constant, so just use r^2)
masses = (radii**2).astype(np.float32)
# Assign random colors (Yellow or Orange) to each particle
colors_list = [random.choice([YELLOW, ORANGE]) for _ in range(NUM_PARTICLES)]
# Store recent positions for drawing trails
trail_history = np.zeros((NUM_PARTICLES, TRAIL_LENGTH, 2), dtype=np.float32)
# Store the last applied temperature factor for each particle (used in temp calculation)
current_temp_factors = np.ones(NUM_PARTICLES, dtype=np.float32) * 1.0

# Initial Particle Placement
# Distribute particles randomly within the initial balloon radius
angles = np.random.uniform(0, 2 * math.pi, NUM_PARTICLES) # Random angles
# Ensure particles start inside, considering their own radius
max_initial_dist = current_balloon_radius - radii.max()
# Use sqrt of uniform distribution for even radial distribution
radii_dist = np.sqrt(np.random.uniform(0, 1, NUM_PARTICLES)) * max_initial_dist
# Convert polar coordinates (angle, radius_dist) to Cartesian (x, y) relative to center
positions[:, 0] = BALLOON_CENTER[0] + radii_dist * np.cos(angles)
positions[:, 1] = BALLOON_CENTER[1] + radii_dist * np.sin(angles)
# Initialize trail history with the starting positions
trail_history[:] = positions[:, np.newaxis, :]

# Initial Particle Velocities
# Give particles a small initial random velocity
angles_vel = np.random.uniform(0, 2 * math.pi, NUM_PARTICLES)
velocities[:, 0] = np.cos(angles_vel) * PARTICLE_BASE_SPEED
velocities[:, 1] = np.sin(angles_vel) * PARTICLE_BASE_SPEED

# UI Elements
temp_slider = Slider(SLIDER_X, SLIDER_Y, SLIDER_WIDTH, SLIDER_HEIGHT,
                     SLIDER_MIN_TEMP, SLIDER_MAX_TEMP, 1.0) # Initial temp factor = 1.0

# Clouds
clouds = [Cloud() for _ in range(NUM_CLOUDS)] # Create cloud objects

# Game State Variables
exploding = False         # Flag indicating if the explosion sequence is active
explosion_effect = None   # Stores the ExplosionEffect object when active
particle_grid = {}        # Dictionary for the spatial grid optimization
processed_pairs = set()   # Set for tracking processed particle pairs in collision detection

# --- Game Loop ---
running = True
while running:
    # --- 1. Event Handling ---
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        # Handle slider events only if not currently exploding
        if not exploding:
            # Pass the PIXEL_SCALE factor for correct coordinate conversion
            temp_slider.handle_event(event, PIXEL_SCALE)

    # --- 2. Updates ---

    # Update cloud positions regardless of explosion state
    for cloud in clouds:
        cloud.update()

    if not exploding:
        # --- Normal Simulation Updates ---
        target_temp_factor = temp_slider.get_value() # Get desired temperature from slider

        # Update Balloon Radius based on temperature
        # Target radius increases with square root of temperature (like ideal gas volume)
        # Add a small multiplier for visual effect
        target_radius = BALLOON_BASE_RADIUS * math.sqrt(target_temp_factor) * 1.1
        # Smoothly interpolate current radius towards the target radius
        current_balloon_radius += (target_radius - current_balloon_radius) * 0.05
        # Ensure radius doesn't shrink below 1 pixel
        current_balloon_radius = max(1.0, current_balloon_radius)

        # Update Particle Physics
        set_temperature_np(velocities, current_temp_factors, target_temp_factor) # Adjust particle speeds
        move_particles_np(positions, velocities, trail_history)                 # Move particles
        collide_balloon_np(positions, velocities, radii, BALLOON_CENTER, current_balloon_radius) # Handle balloon boundary collisions
        velocities *= DAMPING # Apply velocity damping

        # Grid-Based Particle-Particle Collisions
        particle_grid.clear() # Clear grid from previous frame
        # Calculate cell coordinates for all particles
        cell_coords_all = get_cell_coords(positions)
        # Populate the grid dictionary
        for i in range(NUM_PARTICLES):
            cell = tuple(cell_coords_all[i])
            if cell not in particle_grid:
                particle_grid[cell] = []
            particle_grid[cell].append(i)
        # Perform collision checks using the grid
        collide_particles_np_grid(positions, velocities, radii, masses, particle_grid, processed_pairs)

        # Check for Explosion Condition
        if current_balloon_radius > SECRET_EXPLOSION_RADIUS:
            exploding = True
            # Create the explosion visual effect centered on the balloon
            explosion_effect = ExplosionEffect(
                tuple(BALLOON_CENTER.astype(int)), # Ensure integer coordinates for effect center
                EXPLOSION_PARTICLES,
                EXPLOSION_DURATION,
                EXPLOSION_MAX_RADIUS,
                EXPLOSION_COLORS
            )
            # Give the original particles an outward velocity boost upon explosion
            directions = positions - BALLOON_CENTER # Vectors from center to particles
            norms = np.linalg.norm(directions, axis=1)
            safe_norms = np.maximum(norms, EPSILON) # Avoid division by zero
            directions /= safe_norms[:, np.newaxis] # Normalize direction vectors
            # Apply random outward speed boost
            velocities = directions * np.random.uniform(1.5, 4.5, NUM_PARTICLES)[:, np.newaxis]

    else:
        # --- Updates During Explosion ---
        # Update the explosion visual effect (particles, shockwave)
        if explosion_effect:
            active = explosion_effect.update()
            # If the effect finishes, remove it
            if not active:
                explosion_effect = None
                # Optional: uncomment to quit the game after the explosion fades
                # running = False

        # Update the original particles (now acting as debris)
        positions += velocities # Continue moving outward
        velocities *= 0.985 # Apply stronger damping to debris

    # --- 3. Drawing (Render onto the low-resolution pixel_surface) ---
    pixel_surface.fill(SKY_BLUE) # Clear surface with sky color

    # Draw Clouds (draw first, so they are behind everything else)
    for cloud in clouds:
        cloud.draw(pixel_surface)

    if not exploding:
        # --- Drawing during Normal Simulation ---

        # Draw Balloon String (before the balloon itself)
        string_start_x = int(BALLOON_CENTER[0])
        # Start string at the bottom-center of the balloon
        string_start_y = int(BALLOON_CENTER[1] + current_balloon_radius)
        string_end_y = string_start_y + STRING_LENGTH
        # Draw a simple 1-pixel wide line for the string
        pygame.draw.line(pixel_surface, STRING_COLOR,
                         (string_start_x, string_start_y),
                         (string_start_x, string_end_y), 1)

        # Draw Balloon (Outline and Fill)
        radius_int = int(current_balloon_radius)
        center_int = BALLOON_CENTER.astype(int) # Use integer coordinates for drawing
        if radius_int > 0: # Only draw if radius is positive
            # Draw the outline (1 pixel wide)
            pygame.draw.circle(pixel_surface, DARK_RED, center_int, radius_int, width=1)

            # Draw the fill with slight transparency
            # Create a temporary surface for the balloon fill to handle alpha blending correctly
            temp_balloon_surf = pygame.Surface((radius_int * 2, radius_int * 2), pygame.SRCALPHA)
            temp_balloon_surf.fill((0,0,0,0)) # Ensure fully transparent background
            # Draw the balloon color with alpha onto the temporary surface
            pygame.draw.circle(temp_balloon_surf, (*BALLOON_COLOR, 200), # Base color + alpha value (0-255)
                               (radius_int, radius_int), radius_int) # Center on temp surface
            # Blit the temporary surface onto the main pixel surface
            pixel_surface.blit(temp_balloon_surf,
                               (center_int[0] - radius_int, center_int[1] - radius_int))


        # Draw Particle Trails
        for i in range(NUM_PARTICLES):
            # Select only recent, valid points from trail history for drawing
            # Check only the first half of the trail to reduce visual clutter/length
            valid_mask = np.any(trail_history[i, :TRAIL_LENGTH//2] != 0, axis=1)
            # Need at least two points to draw a line segment
            if np.sum(valid_mask) > 1:
                # Convert valid points to integer list for drawing
                trail_points_int = trail_history[i, :TRAIL_LENGTH//2][valid_mask].astype(int).tolist()
                if len(trail_points_int) > 1:
                    try:
                         # Draw the trail as connected line segments (1 pixel wide)
                         pygame.draw.lines(pixel_surface, colors_list[i], False, trail_points_int, 1)
                    except (ValueError, OverflowError):
                         pass # Ignore drawing errors if coordinates are invalid

        # Draw Particles
        for i in range(NUM_PARTICLES):
            pos_int = positions[i].astype(int)
            radius_int = int(radii[i])
            if radius_int > 0: # Only draw if radius is at least 1
                # Draw particles as small rectangles for a blocky pixel style
                # Center the rectangle on the particle's position
                pygame.draw.rect(pixel_surface, colors_list[i],
                                 (pos_int[0] - radius_int // 2, pos_int[1] - radius_int // 2,
                                  radius_int, radius_int))
                # Alternative: Draw as circles
                # pygame.draw.circle(pixel_surface, colors_list[i], pos_int, radius_int)

        # Draw UI Elements
        temp_slider.draw(pixel_surface, font) # Draw the temperature slider

        # Draw Info Text (Top-Left Corner)
        radius_text = font.render(f"R:{current_balloon_radius:.0f}", True, BLACK)
        pixel_surface.blit(radius_text, (3, 3))
        # Optional: Display particle count
        # num_particles_text = font.render(f"N:{NUM_PARTICLES}", True, BLACK)
        # pixel_surface.blit(num_particles_text, (3, 3 + font.get_height()))

        # Draw Explosion Warning Text
        # Show warning when balloon radius gets close to the explosion threshold
        if current_balloon_radius > SECRET_EXPLOSION_RADIUS * 0.85:
            warning_text = font.render("!!!", True, RED)
            pixel_surface.blit(warning_text, (3, 3 + font.get_height())) # Position below radius text

    else:
        # --- Drawing during Explosion ---

        # Draw original particles flying outwards (debris)
        for i in range(NUM_PARTICLES):
            pos_int = positions[i].astype(int)
            radius_int = int(radii[i])
            if radius_int > 0:
                 # Draw debris as small rectangles
                 pygame.draw.rect(pixel_surface, colors_list[i],
                                  (pos_int[0] - radius_int // 2, pos_int[1] - radius_int // 2,
                                   radius_int, radius_int))

        # Draw the explosion effect (shockwave and effect particles)
        if explosion_effect:
            explosion_effect.draw(pixel_surface)


    # --- 4. Scale and Display ---
    # Scale the low-resolution pixel_surface up to the high-resolution screen
    # This creates the pixelated aesthetic
    pygame.transform.scale(pixel_surface, (WIDTH, HEIGHT), screen)

    pygame.display.flip() # Update the entire screen to show the newly drawn frame
    clock.tick(FPS)       # Wait to maintain the target frame rate

# --- Game Exit ---
pygame.quit() # Uninitialize Pygame modules